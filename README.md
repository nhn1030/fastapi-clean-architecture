# clean architecture (with repository pattern)

이 아키텍처 구조는 **클린 아키텍처** 및 **계층형 아키텍처**의 장점을 살리면서, 리포지토리 패턴을 중심으로 데이터를 분리하는 방식입니다. 각 레이어가 역할에 맞게 분리되어 있으며, 의존성이 적절히 역방향으로 흐르게 되어 **확장성**, **테스트 용이성**, **유지 보수** 측면에서 긍정적인 영향을 미칠 수 있습니다. 아래는 이 아키텍처의 구성 요소 및 각 레이어의 역할에 대한 설명입니다. ✨

## 아키텍처 구성

```bash
src
│
├── models          # 데이터베이스 모델들
├── repositories    # 실제 DB와 상호작용하는 레이어
│
├── services        # 비즈니스 로직 및 도메인 서비스
├── routers      `  # API 라우터
│
└── schemas         # 데이터 검증 및 API 입력/출력 스키마

```

---

## 각 레이어 설명

### **1. models** 🗂️

- **역할**: 데이터베이스 모델을 정의하는 곳입니다. 이 레이어는 실제 DB 테이블을 매핑하는 ORM 모델들이 위치합니다.
- **목표**: 데이터베이스 구조와의 일관성을 유지하고, DB와의 상호작용을 추상화하는 역할을 합니다.
- **장점**: 도메인 모델과 데이터베이스 모델을 분리하여, 데이터베이스에 종속되지 않게 도메인 로직을 관리할 수 있습니다.

### **2. repositories** 🏗️

- **역할**: DB와의 실제 상호작용을 처리하는 부분입니다. 데이터를 추가/수정/삭제하는 기능을 담당합니다.
- **목표**: DB에서 데이터를 가져오고, 변경하는 책임을 담당하며, 서비스 레이어에서 DB에 접근할 필요 없이 리포지토리를 통해 데이터를 처리할 수 있도록 합니다.
- **장점**: DB와의 세부 구현을 캡슐화하여, 서비스 레이어에서 DB 기술에 의존하지 않게 하여 추상화합니다.
  - **예시**: `get_user_by_id(id)`, `create_order(data)`와 같은 메서드들이 여기에 위치합니다.

### **3. services** 💼

- **역할**: 비즈니스 로직과 도메인 규칙을 처리하는 레이어입니다. 도메인 서비스는 상위 레벨에서 비즈니스 규칙을 처리하고, 필요한 경우 데이터 레이어를 호출하여 데이터를 처리합니다.
- **목표**: 서비스 레이어에서는 도메인 로직에만 집중하며, DB 세부 구현은 `repositories`와 분리됩니다.
- **장점**: 도메인 로직이 DB나 외부 API에 의존하지 않으므로, 비즈니스 규칙을 유연하게 관리할 수 있습니다.
  - **예시**: `order_service.create_order()`, `user_service.validate_user()`와 같은 비즈니스 로직을 처리하는 함수들이 여기에 포함됩니다.

### **4. routers** 🌐

- **역할**: API 엔드포인트를 정의하는 곳입니다. 사용자가 요청을 보낼 수 있도록 라우터를 설정합니다.
- **목표**: API 요청을 받아 해당하는 서비스 로직을 호출하고, 결과를 반환합니다.
- **장점**: 클라이언트와 서버 간의 명확한 인터페이스를 제공하며, API 요청/응답을 처리하는 로직을 집중적으로 관리할 수 있습니다.

### **5. schemas** 📝

- **역할**: FastAPI와의 통신을 위한 데이터 검증 및 직렬화/역직렬화 처리를 담당합니다. 이 레이어는 API의 요청 및 응답을 정의하고, 유효성 검사를 합니다.
- **목표**: API와의 인터페이스에서 들어오는 데이터에 대한 검증 및 응답 데이터를 정의하여 API의 입력과 출력을 관리합니다.
- **장점**: Pydantic 모델을 사용하여 API 요청의 유효성 검사를 명확히 할 수 있습니다. 데이터 검증을 통해 서비스의 신뢰성을 높일 수 있습니다.

---

## 아키텍처의 장점 🌟

### 1. **비즈니스 로직과 데이터베이스 로직 분리** 🔄

- DB 세부 사항은 `repositories`에서 처리되고, 비즈니스 로직은 `services`에서 처리됩니다. 따라서 각 레이어의 책임이 명확하게 분리됩니다.
- 데이터베이스가 변경되거나 다른 기술로 바뀌더라도 서비스 레이어에 영향을 주지 않도록 할 수 있습니다.

### 2. **유지보수성 및 확장성** 📈

- 각 레이어가 독립적으로 관리되므로, 애플리케이션이 성장할수록 각 모듈을 독립적으로 확장하고 변경할 수 있습니다.
- 새로운 기능을 추가할 때 비즈니스 로직만 수정하면 되므로, 기존 시스템에 미치는 영향을 최소화할 수 있습니다.

### 3. **테스트 용이성** 🔍

- 각 레이어를 독립적으로 테스트할 수 있습니다. 예를 들어, `services`의 비즈니스 로직은 `repositories`를 mock 처리하여 단위 테스트할 수 있습니다.
- DB와의 상호작용이 필요할 때는 더미 데이터를 사용할 수 있어, 데이터베이스와의 연결 없이도 테스트가 가능합니다.

### 4. **의존성 역전 원칙 (Dependency Inversion Principle)** 🔄

- 서비스 계층이 데이터베이스에 의존하지 않도록 인터페이스를 정의하고, 구현은 `repositories`에서 이루어집니다.
- 이를 통해 서비스 계층은 DB와 독립적이며, DB를 변경하거나 교체하더라도 서비스 계층을 수정할 필요가 없습니다.

### 5. **비즈니스 로직과 API의 명확한 분리** 🎯

- API 요청/응답을 다루는 `schemas` 레이어와 비즈니스 로직을 다루는 `services` 레이어가 분리됩니다.
- API 계층과 비즈니스 로직이 독립적으로 유지될 수 있습니다.


작성자: nhn1030
